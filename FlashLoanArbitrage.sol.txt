
// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "@aave/core-v3/contracts/flashloan/base/FlashLoanSimpleReceiverBase.sol";
import "@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol";
import "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol";


interface IUniswapV2Router02 {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function factory() external pure returns (address);
}

contract AaveV3FlashLoan is FlashLoanSimpleReceiverBase {
    address public owner;
    IUniswapV2Router02 public immutable router;

    event FlashLoanRequested(address indexed asset, uint256 amount);
    event SwapExecuted(address indexed fromToken, address indexed toToken, uint256 amountIn, uint256 amountOut);
    event ProfitWithdrawn(address indexed to, address token, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    constructor(address _provider, address _router) FlashLoanSimpleReceiverBase(IPoolAddressesProvider(_provider)) {
        owner = msg.sender;
        router = IUniswapV2Router02(_router);
    }


    function requestFlashLoan(address asset, uint256 amount, bytes calldata params) external onlyOwner {
        emit FlashLoanRequested(asset, amount);
        // referralCode set to 0
        POOL.flashLoanSimple(address(this), asset, amount, params, 0);
    }

   
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external override returns (bool) {
        require(msg.sender == address(POOL), "Caller must be pool");
        require(initiator == address(this), "Initiator must be this contract");

        // Decode params expected format:
        // abi.encode(address[] path, uint256 amountOutMin)
        (address[] memory path, uint256 amountOutMin) = abi.decode(params, (address[], uint256));

        // Example logic: swap borrowed asset -> path[last]
        // Approve router to pull 'asset'
        IERC20(asset).approve(address(router), amount);

        uint256 beforeBalance = IERC20(path[path.length - 1]).balanceOf(address(this));

        // Perform the swap on UniswapV2-compatible router
        uint[] memory amounts = router.swapExactTokensForTokens(
            amount,
            amountOutMin,
            path,
            address(this),
            block.timestamp
        );

        uint256 afterBalance = IERC20(path[path.length - 1]).balanceOf(address(this));
        uint256 amountOut = 0;
        if (afterBalance > beforeBalance) {
            amountOut = afterBalance - beforeBalance;
        } else if (amounts.length > 0) {
            amountOut = amounts[amounts.length - 1];
        }

        emit SwapExecuted(asset, path[path.length - 1], amount, amountOut);

        // Repay loan + premium
        uint256 totalDebt = amount + premium;


        // Approve pool to pull the owed amount
        IERC20(asset).approve(address(POOL), totalDebt);

        return true;
    }


    // Withdraw ERC20 profits to owner
    function withdrawToken(address token) external onlyOwner {
        uint256 bal = IERC20(token).balanceOf(address(this));
        require(bal > 0, "No balance");
        IERC20(token).transfer(owner, bal);
        emit ProfitWithdrawn(owner, token, bal);
    }


    function setOwner(address newOwner) external onlyOwner {
        require(newOwner != address(0), "Zero address");
        owner = newOwner;
    }

    // Receive fallback
    receive() external payable {}
}
